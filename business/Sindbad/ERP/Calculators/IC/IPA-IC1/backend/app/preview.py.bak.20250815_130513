
from __future__ import annotations
from typing import Any, Dict, List
from datetime import date
import calendar

# Engine imports (monolith or package-style)
from app.engine import run_calc, Inputs  # type: ignore

# ------------------------
# date helpers
# ------------------------
def _parse_date(payload: Dict[str, Any]) -> date:
    for k in ("start_date","contract_start_date","ipa_start_date","ipa_start","contract_date","start"):
        v = payload.get(k)
        if isinstance(v, str):
            s = v.strip().replace('/', '-')
            parts = s.split('-')
            try:
                if len(parts) == 3:
                    if len(parts[0]) == 4:       # YYYY-MM-DD
                        y, m, d = int(parts[0]), int(parts[1]), int(parts[2])
                    else:                         # MM-DD-YYYY
                        m, d, y = int(parts[0]), int(parts[1]), int(parts[2])
                        if y < 100: y += 2000
                    return date(y, m, d)
            except Exception:
                pass
    return date.today()

def _add_months(dt: date, n: int) -> date:
    y = dt.year + (dt.month - 1 + n) // 12
    m = (dt.month - 1 + n) % 12 + 1
    last = calendar.monthrange(y, m)[1]
    d = min(dt.day, last)
    return date(y, m, d)

# ------------------------
# numeric helpers
# ------------------------
def _f(x, default=0.0):
    try: return float(x)
    except Exception: return float(default)

def _sum_interest(schedule: List[Dict[str, Any]]) -> float:
    tot = 0.0
    for row in schedule or []:
        tot += _f(row.get("interest", 0))
    return round(tot, 2)

def _vat_from_result(res: Dict[str, Any]) -> float:
    for k in ("ipa_vat", "vat_ipa", "vat_total", "vat"):
        if k in res:
            try: return float(res[k])
            except Exception: pass
    ssum = 0.0
    for row in res.get("schedule", []) or []:
        v = row.get("vat")
        if v is not None:
            try: ssum += float(v)
            except Exception: pass
    return round(ssum, 2)

def _vat_asset_from_payload(payload: Dict[str, Any]) -> float:
    # prefer explicit asset_vat
    if "asset_vat" in payload:
        try: return float(payload["asset_vat"])
        except Exception: pass
    gross = _f(payload.get("asset_value_gross", payload.get("asset_gross", 0.0)))
    vr = _f(payload.get("vat_rate", 0.0))
    if vr > 1.0:   # percent form like 18
        vr = vr/100.0
    return round(gross*vr, 2) if gross and vr else 0.0

# ------------------------
# main adapter
# ------------------------
def compute_preview(payload: Dict[str, Any]) -> Dict[str, Any]:
    p = dict(payload)

    # normalize common fields
    if "nominal_rate_annual" in p and "rate" not in p:
        p["rate"] = p["nominal_rate_annual"]
    p.setdefault("term_months", int(p.get("term", p.get("tenor", 0)) or 0))
    p["vat_rate"] = _f(p.get("vat_rate", 0.0))
    p["principal"] = _f(p.get("principal", 0.0))

    # *** WHITELIST ONLY ENGINE-FRIENDLY FIELDS ***
    allowed = {
        "principal","rate","term_months","balloon","vat_rate",
        "asset_vat","telematics_monthly","include_irc","include_banking",
        "irc_rate","banking_rate"
    }
    eng_payload = {k: p[k] for k in allowed if k in p}

    # run engine
    result = run_calc(Inputs(**eng_payload))

    # derive d/e/c/f
    d = _f(eng_payload.get("principal", 0.0))
    ipa_net = _f(result.get("ipa_net", 0.0))
    ipa_vat = _f(result.get("ipa_vat", 0.0))
    e = round(ipa_net + ipa_vat, 2)
    c = _sum_interest(result.get("schedule", []))

    # f via solver if available; fallback to direct diff
    try:
        from app.equilibrium import solve_equilibrium_f_bisect  # type: ignore
        eq = solve_equilibrium_f_bisect({
            "principal": d,
            "term_months": int(p.get("term_months", 0)),
            "rate": _f(p.get("rate", 0.0)),
            "vat_rate": _f(p.get("vat_rate", 0.0))
        })
        f = _f(eq.get("equilibrium", {}).get("f_solved", None))
        if not f:
            f = round(_vat_from_result(result) - _vat_asset_from_payload(p), 2)
    except Exception:
        f = round(_vat_from_result(result) - _vat_asset_from_payload(p), 2)

    # payments preview
    term = int(p.get("term_months", 0)) or len(result.get("schedule", []) or [])
    annuity_net = _f(result.get("annuity", 0.0))
    vat_pm = round((ipa_vat / term), 2) if term else 0.0
    start = _parse_date(p)
    payments: List[Dict[str, Any]] = []
    for i in range(term):
        dt = _add_months(start, i)
        total = round(annuity_net + vat_pm, 2)
        payments.append({
            "idx": i + 1,
            "date": dt.isoformat(),
            "annuity_net": round(annuity_net, 2),
            "vat": vat_pm,
            "total": total
        })

    return {
        "inputs": p,
        "d": round(d, 2),
        "e": round(e, 2),
        "c": round(c, 2),
        "f": round(f, 2),
        "payments": payments,
        "engine_result": result,
    }
