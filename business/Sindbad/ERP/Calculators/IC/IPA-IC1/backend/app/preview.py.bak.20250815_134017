
from __future__ import annotations
from typing import Any, Dict, List
from datetime import date
import math

# engine
from app.engine import run_calc, Inputs

# -------- helpers

def _num(x, default=0.0) -> float:
    try:
        if x is None or x == "":
            return float(default)
        return float(x)
    except Exception:
        return float(default)

def _int(x, default=0) -> int:
    try:
        if x is None or x == "":
            return int(default)
        return int(float(x))
    except Exception:
        return int(default)

def _parse_date(s: str | None, fallback: str = "2025-09-01") -> date:
    from datetime import datetime
    s = (s or fallback).strip()
    try:
        return datetime.fromisoformat(s).date()
    except Exception:
        # try mm/dd/yyyy
        try:
            return datetime.strptime(s, "%m/%d/%Y").date()
        except Exception:
            return datetime.fromisoformat(fallback).date()

def _add_months(d: date, n: int) -> date:
    # safe month add (clamp day to 28)
    y = d.year + (d.month - 1 + n) // 12
    m = (d.month - 1 + n) % 12 + 1
    day = min(d.day, 28)
    return date(y, m, day)

# -------- core adapter

def compute_preview(payload: Dict[str, Any]) -> Dict[str, Any]:
    """
    Compatibility layer so UI v11.4 can render:
      - d/e/c/f at top level
      - schedule/payments with expected field names
      - VAT summary (asset, IPA, delta)
      - ok flag
    """
    # 1) Normalize inputs for the engine
    term = _int(payload.get("term_months") or payload.get("tenure_months") or 0)
    rate = _num(payload.get("rate") or payload.get("nominal_rate_annual") or 0.0)
    vat_rate = _num(payload.get("vat_rate") or 0.0)
    principal = _num(payload.get("principal") or payload.get("credit_base") or 0.0)

    # try to reconstruct asset VAT (used in UI's VAT report / 'f')
    asset_gross = _num(payload.get("asset_gross") or payload.get("asset_value_gross") or payload.get("asset") or 0.0)
    asset_net = _num(payload.get("asset_net") or payload.get("asset_value_net") or 0.0)
    asset_vat = asset_gross - asset_net if asset_gross and asset_net else round(asset_net * vat_rate, 2) if asset_net and vat_rate else 0.0

    start_s = payload.get("start_date") or payload.get("contract_start_date")
    start = _parse_date(start_s)

    # 2) Run the engine (engine does not care about dates)
    eng_inputs = {"principal": principal, "term_months": term, "rate": rate, "vat_rate": vat_rate}
    result = run_calc(Inputs(**eng_inputs))

    # expected engine fields
    annuity = float(getattr(result, "annuity", 0.0))
    ipa_net = float(getattr(result, "ipa_net", 0.0))
    ipa_vat = float(getattr(result, "ipa_vat", 0.0))
    # engine may expose schedule with per-period annuity
    schedule = getattr(result, "schedule", []) or []

    # 3) Derived magnitudes for UI
    d = principal
    e = ipa_net + ipa_vat                    # IPA inclusive of VAT
    f = ipa_vat - asset_vat                  # VAT(IPA) â€“ VAT(asset)
    c = ipa_net - principal                  # net finance margin proxy (UI only needs e,f,d for pending rows)

    # Build per-month rows in the shape the HTML might expect
    # If engine didn't supply dates, synthesize them
    rows: List[Dict[str, Any]] = []
    for i in range(term):
        row_date = _add_months(start, i)
        # take engine annuity if schedule has it, else constant annuity
        eng_row = schedule[i] if i < len(schedule) else {}
        a = float(eng_row.get("annuity", annuity)) if isinstance(eng_row, dict) else annuity
        v = round(a * vat_rate, 2)
        t = round(a + v, 2)
        rows.append({
            # names the UI might read
            "idx": i + 1,
            "date": row_date.isoformat(),
            "annuity": a,            # alias
            "annuity_net": a,        # alias used by our adapter earlier
            "vat": v,
            "vat_amount": v,         # alias
            "total": t,
            "total_incl_vat": t      # alias
        })

    out: Dict[str, Any] = {
        # top level flags / magnitudes used by UI cards
        "ok": True,
        "d": round(d, 2),
        "e": round(e, 2),
        "c": round(c, 2),
        "f": round(f, 2),

        # VAT summary block (multiple keys so HTML finds something)
        "vat_asset": round(asset_vat, 2),
        "vat_input_asset": round(asset_vat, 2),
        "vat_ipa": round(ipa_vat, 2),
        "vat_output_ipa": round(ipa_vat, 2),
        "vat_delta": round(f, 2),

        # payments list in several compatible shapes
        "payments": rows,
        "schedule": rows,  # alias for older UI code
    }

    # echo minimal engine bits for future tabs (optional)
    out["engine"] = {
        "annuity": annuity,
        "ipa_net": ipa_net,
        "ipa_vat": ipa_vat,
    }

    return out
