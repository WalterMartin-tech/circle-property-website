from datetime import datetime, timedelta, timezone
from typing import Optional, List, Literal, Dict, Any

from fastapi import FastAPI, Depends, HTTPException, Header
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm
from jose import jwt, JWTError
from passlib.context import CryptContext
from pydantic import BaseModel
from sqlalchemy import (
    create_engine, Integer, String, DateTime, JSON, ForeignKey, select, UniqueConstraint
)
from sqlalchemy.orm import sessionmaker, DeclarativeBase, Mapped, mapped_column, relationship

# ---------------- Settings ----------------
JWT_SECRET = "dev-secret-change-me"  # change in prod
JWT_ALG = "HS256"
JWT_EXP_DAYS = 90

DATABASE_URL = "sqlite:///./ipa.sqlite3"  # dev: file DB
engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False})
SessionLocal = sessionmaker(bind=engine, expire_on_commit=False)

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


# ---------------- DB models ----------------
class Base(DeclarativeBase):
    pass


class User(Base):
    __tablename__ = "users"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    email: Mapped[str] = mapped_column(String, unique=True, index=True)
    hashed_password: Mapped[str] = mapped_column(String)
    role: Mapped[str] = mapped_column(String, default="user")  # dev | admin | user
    issued_at: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))


class Customer(Base):
    __tablename__ = "customers"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    name: Mapped[str] = mapped_column(String, unique=True, index=True)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))


class Calc(Base):
    __tablename__ = "calculations"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    customer_id: Mapped[int] = mapped_column(ForeignKey("customers.id"))
    stage: Mapped[str] = mapped_column(String)            # pre | contract | lifetime
    draft_status: Mapped[Optional[str]] = mapped_column(String, nullable=True)  # in_review | approved | rejected
    calc_version: Mapped[str] = mapped_column(String, default="1.0.0")
    created_by: Mapped[str] = mapped_column(String)
    created_at: Mapped[datetime] = mapped_column(DateTime, default=lambda: datetime.now(timezone.utc))

    # IDs
    date_stamp: Mapped[str] = mapped_column(String)       # YYYYMMDD
    global_seq: Mapped[int] = mapped_column(Integer)      # never resets
    draft_no: Mapped[int] = mapped_column(Integer)        # per-customer running

    # Contract numbering (stage = contract)
    ipa_year: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)
    ipa_seq: Mapped[Optional[int]] = mapped_column(Integer, nullable=True)

    data: Mapped[Dict[str, Any]] = mapped_column(JSON)

    customer: Mapped["Customer"] = relationship()


class GlobalCounter(Base):
    __tablename__ = "global_counter"
    id: Mapped[int] = mapped_column(Integer, primary_key=True, default=1)
    value: Mapped[int] = mapped_column(Integer, default=0)


class DraftCounter(Base):
    __tablename__ = "draft_counters"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    customer_id: Mapped[int] = mapped_column(ForeignKey("customers.id"))
    last_draft_no: Mapped[int] = mapped_column(Integer, default=0)
    __table_args__ = (UniqueConstraint("customer_id", name="uq_draft_by_customer"),)


class IPASeq(Base):
    __tablename__ = "ipa_seq"
    id: Mapped[int] = mapped_column(Integer, primary_key=True)
    year: Mapped[int] = mapped_column(Integer, index=True)
    last_seq: Mapped[int] = mapped_column(Integer, default=0)
    __table_args__ = (UniqueConstraint("year", name="uq_year_seq"),)


Base.metadata.create_all(engine)

# Seed admin user if missing
with SessionLocal() as _db:
    if not _db.execute(select(User).where(User.email == "admin@example.com")).scalar_one_or_none():
        _db.add(User(email="admin@example.com", hashed_password=pwd_context.hash("admin"), role="admin"))
        _db.commit()


# ---------------- Schemas ----------------
Role = Literal["dev", "admin", "user"]
Stage = Literal["pre", "contract", "lifetime"]
DraftStatus = Literal["in_review", "approved", "rejected"]


class Token(BaseModel):
    access_token: str
    token_type: str = "bearer"


class UserOut(BaseModel):
    email: str
    role: Role


class CustomerIn(BaseModel):
    name: str


class CustomerOut(BaseModel):
    id: int
    name: str
    created_at: datetime


class CalcIn(BaseModel):
    clientName: str
    stage: Stage
    draftStatus: Optional[DraftStatus] = None
    createdBy: str
    calcVersion: str = "1.0.0"
    data: Dict[str, Any]
    startDate: Optional[str] = None  # for IPA year suggestion


class CalcOut(BaseModel):
    id: int
    customer: CustomerOut
    stage: Stage
    draftStatus: Optional[DraftStatus]
    calcVersion: str
    createdBy: str
    createdAt: datetime
    dateStamp: str
    globalSeq: int
    draftNo: int
    ipaNumber: Optional[str] = None
    data: Dict[str, Any]


class Defaults(BaseModel):
    vatRate: float = 18.0
    rc: float = 18.0
    rf: float = 6.0
    tseRate: float = 0.10
    loanRegRate: float = 1.00
    taxAuthPledgeAmt: float = 25000
    stampDutyAmt: float = 30000
    onlineRegAmt: float = 6650
    filingMinutesAmt: float = 5000
    teeRate: float = 5.00
    ircRate: float = 18.00
    courtPledgeRate: float = 0.02
    courtPledgeMultiplier: float = 1.5
    bankingFeeRate: float = 2.6
    telematicsCapex: float = 58500
    telematicsMonthly: float = 10000


_SERVER_DEFAULTS = Defaults()


# ---------------- Auth helpers ----------------
def create_token(email: str, role: Role) -> str:
    now = datetime.now(timezone.utc)
    payload = {
        "sub": email,
        "role": role,
        "iat": int(now.timestamp()),
        "exp": int((now + timedelta(days=JWT_EXP_DAYS)).timestamp()),
    }
    return jwt.encode(payload, JWT_SECRET, algorithm=JWT_ALG)


def get_current_user(authorization: Optional[str] = Header(default=None)) -> UserOut:
    if not authorization or not authorization.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing bearer token")
    token = authorization.split(" ", 1)[1]
    try:
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALG])
        return UserOut(email=payload["sub"], role=payload["role"])
    except JWTError:
        raise HTTPException(status_code=401, detail="Invalid token")


def require_role(roles: List[Role]):
    def dep(user: UserOut = Depends(get_current_user)):
        if user.role not in roles:
            raise HTTPException(status_code=403, detail="Insufficient role")
        return user
    return dep


def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# ---------------- App ----------------
app = FastAPI(title="IPA Calculator Backend", version="0.1.0")

# CORS: allow local file (Origin: null) and common dev ports.
# For dev simplicity we allow all origins and no credentials.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],          # dev: wide-open; tighten for prod
    allow_credentials=False,
    allow_methods=["*"],
    allow_headers=["*"],
)


# -------- Auth --------
@app.post("/auth/login", response_model=Token)
def login(form: OAuth2PasswordRequestForm = Depends(), db=Depends(get_db)):
    user = db.execute(select(User).where(User.email == form.username)).scalar_one_or_none()
    if not user or not pwd_context.verify(form.password, user.hashed_password):
        raise HTTPException(status_code=400, detail="Incorrect email or password")
    token = create_token(user.email, user.role)
    return Token(access_token=token)


@app.get("/auth/me", response_model=UserOut)
def me(user: UserOut = Depends(get_current_user)):
    return user


# -------- Defaults --------
@app.get("/defaults", response_model=Defaults)
def get_defaults():
    return _SERVER_DEFAULTS


@app.put("/defaults", response_model=Defaults)
def set_defaults(payload: Defaults, _user: UserOut = Depends(require_role(["dev", "admin"]))):
    global _SERVER_DEFAULTS
    _SERVER_DEFAULTS = payload
    return _SERVER_DEFAULTS


# -------- Customers --------
@app.post("/customers", response_model=CustomerOut)
def create_customer(payload: CustomerIn, db=Depends(get_db), _user: UserOut = Depends(require_role(["dev", "admin", "user"]))):
    name = payload.name.strip()
    if not name:
        raise HTTPException(400, "Name required")
    existing = db.execute(select(Customer).where(Customer.name == name)).scalar_one_or_none()
    if existing:
        return CustomerOut(id=existing.id, name=existing.name, created_at=existing.created_at)
    c = Customer(name=name)
    db.add(c); db.commit(); db.refresh(c)
    return CustomerOut(id=c.id, name=c.name, created_at=c.created_at)


@app.get("/customers", response_model=List[CustomerOut])
def list_customers(db=Depends(get_db), _user: UserOut = Depends(require_role(["dev", "admin", "user"]))):
    rows = db.execute(select(Customer).order_by(Customer.created_at.desc())).scalars().all()
    return [CustomerOut(id=r.id, name=r.name, created_at=r.created_at) for r in rows]


# ---- Counters ----
def next_global_seq(db) -> int:
    row = db.get(GlobalCounter, 1)
    if not row:
        row = GlobalCounter(id=1, value=0)
        db.add(row); db.flush()
    row.value += 1
    db.add(row)
    return row.value


def next_draft_no(db, customer_id: int) -> int:
    row = db.execute(select(DraftCounter).where(DraftCounter.customer_id == customer_id)).scalar_one_or_none()
    if not row:
        row = DraftCounter(customer_id=customer_id, last_draft_no=0)
    row.last_draft_no += 1
    db.merge(row)
    return row.last_draft_no


def next_ipa_seq(db, year: int) -> int:
    row = db.execute(select(IPASeq).where(IPASeq.year == year)).scalar_one_or_none()
    if not row:
        row = IPASeq(year=year, last_seq=0)
    row.last_seq += 1
    db.merge(row)
    return row.last_seq


# -------- Calculations --------
@app.post("/calculations", response_model=CalcOut)
def save_calc(payload: CalcIn, db=Depends(get_db), user: UserOut = Depends(require_role(["dev", "admin", "user"]))):
    cust = db.execute(select(Customer).where(Customer.name == payload.clientName.strip())).scalar_one_or_none()
    if not cust:
        cust = Customer(name=payload.clientName.strip()); db.add(cust); db.flush()

    draft_no = next_draft_no(db, cust.id)
    global_seq = next_global_seq(db)
    date_stamp = datetime.now().strftime("%Y%m%d")

    ipa_year, ipa_seq = None, None
    if payload.stage == "contract":
        year = datetime.now().year
        try:
            if payload.startDate:
                year = datetime.fromisoformat(payload.startDate).year
        except Exception:
            pass
        ipa_year = year
        ipa_seq = next_ipa_seq(db, year)

    rec = Calc(
        customer_id=cust.id,
        stage=payload.stage,
        draft_status=payload.draftStatus if payload.stage == "pre" else None,
        calc_version=payload.calcVersion,
        created_by=payload.createdBy or user.email,
        date_stamp=date_stamp,
        global_seq=global_seq,
        draft_no=draft_no,
        ipa_year=ipa_year,
        ipa_seq=ipa_seq,
        data=payload.data,
    )
    db.add(rec); db.commit(); db.refresh(rec)

    ipa_label = f"IPA-{rec.ipa_year}/{rec.ipa_seq}" if rec.ipa_year and rec.ipa_seq else None
    return CalcOut(
        id=rec.id,
        customer=CustomerOut(id=cust.id, name=cust.name, created_at=cust.created_at),
        stage=rec.stage,
        draftStatus=rec.draft_status,
        calcVersion=rec.calc_version,
        createdBy=rec.created_by,
        createdAt=rec.created_at,
        dateStamp=rec.date_stamp,
        globalSeq=rec.global_seq,
        draftNo=rec.draft_no,
        ipaNumber=ipa_label,
        data=rec.data,
    )


@app.get("/customers/{name}/calculations", response_model=List[CalcOut])
def list_calcs(name: str, db=Depends(get_db), _user: UserOut = Depends(require_role(["dev", "admin", "user"]))):
    cust = db.execute(select(Customer).where(Customer.name == name)).scalar_one_or_none()
    if not cust:
        return []
    rows = db.execute(select(Calc).where(Calc.customer_id == cust.id).order_by(Calc.created_at.desc())).scalars().all()
    out: List[CalcOut] = []
    for rec in rows:
        ipa_label = f"IPA-{rec.ipa_year}/{rec.ipa_seq}" if rec.ipa_year and rec.ipa_seq else None
        out.append(CalcOut(
            id=rec.id,
            customer=CustomerOut(id=cust.id, name=cust.name, created_at=cust.created_at),
            stage=rec.stage,
            draftStatus=rec.draft_status,
            calcVersion=rec.calc_version,
            createdBy=rec.created_by,
            createdAt=rec.created_at,
            dateStamp=rec.date_stamp,
            globalSeq=rec.global_seq,
            draftNo=rec.draft_no,
            ipaNumber=ipa_label,
            data=rec.data,
        ))
    return out


# -------- Compute (preview) --------
class ComputeIn(BaseModel):
    assetGross: Optional[float] = None
    downAmt: Optional[float] = None
    downPct: Optional[float] = None
    courtPledgeRate: float = 0.02
    courtPledgeMultiplier: float = 1.5
    telematicsCapex: float = 58500
    telematicsMonthly: float = 10000
    motorPremiumY1: Optional[float] = None
    teeApplicable: bool = True
    taxAuthPledgeAmt: float = 25000
    stampDutyAmt: float = 30000
    onlineRegAmt: float = 6650
    filingMinutesAmt: float = 5000


class ComputeOut(BaseModel):
    X: Optional[float]
    gKnownSubtotal: float
    parts: List[Dict[str, Any]]
    note: str


@app.post("/compute/preview", response_model=ComputeOut)
def compute_preview(p: ComputeIn):
    def to2(x):
        if x is None:
            return None
        return round(x + 1e-9, 2)

    X = None
    if p.assetGross is not None:
        dp = p.downAmt if p.downAmt is not None else (
            p.assetGross * (p.downPct or 0) / 100.0 if p.downPct is not None else None
        )
        if dp is not None:
            X = p.assetGross - dp

    G = p.taxAuthPledgeAmt
    H = p.stampDutyAmt
    I = p.onlineRegAmt
    J = p.filingMinutesAmt
    P = p.motorPremiumY1 or 0.0
    Q = p.telematicsCapex

    parts = [
        dict(code="X", label="Asset (incl. VAT) − Down Payment", value=to2(X), basis="Gross − DP",
             status="ok" if X is not None else "pending"),
        dict(code="G", label="TAPR", value=to2(G), basis="25,000", status="ok"),
        dict(code="H", label="Stamp Duty", value=to2(H), basis="30,000", status="ok"),
        dict(code="I", label="Online Registration", value=to2(I), basis="6,650", status="ok"),
        dict(code="J", label="Filing Minutes", value=to2(J), basis="5,000", status="ok"),
        dict(code="K", label="Court Pledge", value=None,
             basis=f"{p.courtPledgeRate}% × {p.courtPledgeMultiplier} × e", status="pending"),
        dict(code="F", label="TSE", value=None, basis="0.1% × d", status="pending"),
        dict(code="L", label="TEE (if applicable)", value=None if p.teeApplicable else 0.0,
             basis="5% × e" if p.teeApplicable else "not applicable",
             status="pending" if p.teeApplicable else "ok"),
        dict(code="M", label="Loan Registration", value=None, basis="1% × (b + f), b = g", status="pending"),
        dict(code="P", label="Motor Insurance Y1", value=to2(P), basis="Capitalized",
             status="ok" if p.motorPremiumY1 is not None else "info"),
        dict(code="Q", label="Telematics Equip & Install", value=to2(Q), basis="58,500", status="ok"),
        dict(code="f", label="VAT Delta", value=None, basis="VAT(IPA) − VAT(Asset)", status="pending"),
    ]
    subtotal = round(sum((v["value"] or 0) for v in parts), 2)
    note = "Preview only — %-based & equilibrium terms will compute once IPA d/e/c/f are exposed."

    return ComputeOut(X=to2(X), gKnownSubtotal=subtotal, parts=parts, note=note)
